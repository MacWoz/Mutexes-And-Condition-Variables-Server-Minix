#include "inc.h"
#include "waiters.h"
#include "queue.h"

int call_type;
endpoint_t who_e;

int usedMutexes[1024] = {0};
bool isUsed[1024] = {false};
endpoint_t mutexOwners[1024] = {0};
queue* mutexQueue[1024] = {NULL};

waiters* waitersTable[1024] = {NULL};
bool isWaiterUsed[1024] = {false};

/* SEF functions and variables. */
static void sef_local_startup(void);
static int sef_cb_init_fresh(int type, sef_init_info_t *info);
static void sef_cb_signal_handler(int signo);

int main(int argc, char* argv[])
{
    message m;
    env_setargs(argc, argv);
	sef_local_startup();

	while (1) {
        printf("Next cycle, EDONTREPLY == %d\n", EDONTREPLY);
        int r;
        if ((r = sef_receive(ANY, &m)) != OK) {
            printf("Communication failed!\n");
        }
        else {
            printf ("Success!\n");
        }
		who_e = m.m_source;
		call_type = m.m_type;
		int mutex_id;
		int cvar_id;
		int result;
        printf("CV get %d %d from %d\n", r, call_type, who_e);
        switch (call_type) {
            case MUTEX_LOCK :
                mutex_id = m.m1_i1;
                result = do_lock(mutex_id);
                m.m_type = result;
                break;

            case MUTEX_UNLOCK :
                mutex_id = m.m1_i1;
                result = do_unlock(mutex_id);
                m.m_type = result;
                break;

            case WAIT :
                mutex_id = m.m1_i1;
                cvar_id = m.m1_i2;
                result = do_wait(cvar_id, mutex_id);
                m.m_type = result;
                break;

            case BROADCAST :
                cvar_id = m.m1_i2;
                result = do_broadcast(cvar_id);
                m.m_type = result;
                break;

            default:
                printf("CV warning: got illegal request from %d\n", who_e);
                m.m_type = -EINVAL;
                result = EINVAL;
        }
        if (result != EDONTREPLY) {
            int endRes = send(who_e, &m);
            printf ("OK, sent reply, result %d\n", endRes);
        }
	}
	/* Never gets here */
	return -1;
}

static void sef_local_startup()
{
    /* Register init callbacks. */
    sef_setcb_init_fresh(sef_cb_init_fresh);
    sef_setcb_init_restart(sef_cb_init_fresh);

    /* Register signal callbacks. */
    sef_setcb_signal_handler(sef_cb_signal_handler);
    /* Let SEF perform startup. */
    sef_startup();
}

static int sef_cb_init_fresh(int UNUSED(type), sef_init_info_t *UNUSED(info))
{
    return OK;
}

static void sef_cb_signal_handler(int signo) { }

int do_lock (int mutex_id) {
    int i;
    bool used = false;
    int position = -1;
    int firstFreePosition = -1;
    for (i=0;i<MAX_MUTEXES_NUMBER;++i) {
        if ((! isUsed[i]) && (firstFreePosition == -1))
            firstFreePosition = i;
        if ((usedMutexes[i] == mutex_id) && (isUsed[i])) {
            used = true;
            position = i;
            break;
        }
    }
    if (used) {
        if (mutexOwners[position] == who_e) /** Chce jeszcze raz ten sam mutex */
            return -1;

        if (mutexQueue[position] == NULL)       /** Jak nie ma jeszcze kolejki */
            mutexQueue[position] = createQueue(mutex_id);

        enqueue(who_e, mutexQueue[position]);
        return EDONTREPLY;
    }
    else {
        usedMutexes[firstFreePosition] = mutex_id;
        isUsed[firstFreePosition] = true;
        mutexOwners[firstFreePosition] = who_e;
        return OK;
    }
}

int do_unlock (int mutex_id) {
    int i;
    for (i=0;i<MAX_MUTEXES_NUMBER;++i) {
        if ((usedMutexes[i] == mutex_id) && (isUsed[i])) {
            if (mutexOwners[i] == who_e) {
                if (mutexQueue[i] == NULL) {
                    isUsed[i] = false;
                }
                else if (isEmpty(mutexQueue[i])) {
                    isUsed[i] = false;
                    destroyQueue(mutexQueue[i]);
                    mutexQueue[i] = NULL;
                }
                else {  /** KtoÅ› czeka w kolejce */
                    endpoint_t nextOwner = pop(mutexQueue[i]);
                    if (isEmpty(mutexQueue[i])) {
                        destroyQueue(mutexQueue[i]);
                        mutexQueue[i] = NULL;
                    }
                    mutexOwners[i] = nextOwner;
                    message mess;
                    mess.type = 0;
                    send(nextOwner, &mess);
                }
            }
            else
                return -EPERM;

            break;
        }
    }
    return OK;
}

int do_wait (int cvar_id, int mutex_id) {
    int mutex_owner = who_e;
    int i;
    bool owner = false;
    for (i=0;i<MAX_MUTEXES_NUMBER;++i) {
        if ((isUsed[i]) && (mutexOwners[i] == mutex_owner) && (usedMutexes[i] == mutex_id)){
            owner = true;
            break;
        }
    }
    if (!owner)
        return -EINVAL;

    do_unlock(mutex_id);
    int firstFreePosition = -1;
    for (i=0;i<MAX_MUTEXES_NUMBER;++i) {
        if ((waitersTable[i] == NULL) && (firstFreePosition == -1))
            firstFreePosition = i;
        else if ((!isWaiterUsed[i]) && (firstFreePosition == -1))
            firstFreePosition = i;

        if (waitersTable[i]->cond_var_id == cvar_id) {
            addToWaiters(waitersTable[i], mutex_owner);
            return EDONTREPLY;
        }
    }
    waitersTable[firstFreePosition] = createWaiters(cvar_id);
    addToWaiters(waitersTable[firstFreePosition], mutex_owner);
    return EDONTREPLY;
}

int do_broadcast (int cvar_id) {
    int i;
    for (i=0;i<MAX_MUTEXES_NUMBER;++i) {
        if ((isWaiterUsed[i]) && (waitersTable[i] != NULL) && (waitersTable[i]->cond_var_id == cvar_id)) {
            int j;
            for (j=0;j<waitersTable[i]->size;++j) {
                endpoint_t caller = who_e;
                who_e = waitersTable[i]->processes[j]
                do_lock(who_e);
            }
            who_e = caller;
            free(waitersTable[i]);
            waitersTable[i] = NULL;
            break;
        }
    }
    return OK;
}
